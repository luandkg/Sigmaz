func somar ( a : num , b : num ) : num {
		reg @R9 -> a;
        reg @R10 -> b;

         PROC -> {

            SET R11;
                MOV 0.0;
                OPE R9 SAX R10;

         }

    	return reg @R11;
}
func menor ( a : num , b : num ) : bool {
	reg @R9 -> a;
        reg @R10 -> b;

         PROC -> {

            SET R1;
                MOV FALSE;
                OPE R9 MOZZ R10;

         }

    	return reg @R1;
}
func inteiro ( a : num ) : num {
	def c : num = 0.0;
	invoke casting -> cast_integer_num ( a ) :: c;
	return c;
}
func decimal ( a : num ) : num {
	def c : num = 0.0;
	invoke casting -> cast_decimal_num ( a ) :: c;
	return c;
}

act println ( a : string , b : num ) {

	   reg @R13 -> a;
       reg @R9 -> b;

         PROC -> {
            PROC CHANGE_LINE;
            PRINT R13;
            SET R13;
            MOV "";
            NUM_STRING R9;
            PRINT R13;
         }

}
operator == ( a : num , b : num ) : bool {
	reg @R9 -> a;
    reg @R10 -> b;

     PROC -> {

        SET R1;
            MOV FALSE;
            OPE R9 OPUAL R10;

     }

	return reg @R1;
}

 act print_empty ( ) {
    PROC -> {
        PROC CHANGE_LINE;
    }
   }

act operando ( geral : num ) {
	def w : num = 0.0;
	print_empty();
	def a1 : num = 0.0;
	def raiz : num = 0.0;
	while ( menor ( a1 , 10.0 ) ) -> {
		println ( "Valor : ", inteiro ( a1 ) );
		def cc : num = somar ( a1 , a1 );
		cc = somar ( geral , cc );
		cc = somar ( inteiro ( cc ) , raiz );
		raiz = somar ( raiz , 0.12 );
		def auxiliar : num;
		if ( inteiro ( cc ) == 15.0 ) -> {
			auxiliar = 5.0;
		}
		if ( inteiro ( cc ) == 17.0 ) -> {
			
		}other ( inteiro ( cc ) == 11.0 ) -> {
			auxiliar = -1.0;
		}others {
			if ( inteiro ( cc ) == 21.0 ) -> {
				auxiliar = 7.0;
			}
			
		}
		if ( inteiro ( cc ) == 19.0 ) -> {
			def passador : num = 1.0;
			def acumulando : num = 0.0;
			step passador :: ( 0.0 , 10.0 , inteiro ( somar ( passador , 1.0 ) ) ) -> {
				acumulando = somar ( acumulando , 2.0 );
			}
			auxiliar = acumulando;
		}others {
			
		}
		if ( inteiro ( cc ) == 21.0 ) -> {
			def passador : num = 1.0;
			def acumulando : num = 0.0;
			step passador :: ( 0.0 , 10.0 , inteiro ( somar ( passador , 1.0 ) ) ) -> {
				if ( passador == 8.0 ) -> {
					cancel;
				}
				if ( passador == 5.0 ) -> {
					continue;
				}
				acumulando = somar ( acumulando , 2.0 );
			}
			auxiliar = acumulando;
		}
		if ( inteiro ( cc ) == 24.0 ) -> {
			def acumulando : num = 0.0;
			step def passador : num :: ( 0.0 , 10.0 , inteiro ( somar ( passador , 1.0 ) ) ) -> {
				if ( passador == 8.0 ) -> {
					cancel;
				}
				if ( passador == 5.0 ) -> {
					continue;
				}
				acumulando = somar ( acumulando , somar ( 2.0 , passador ) );
			}
			auxiliar = acumulando;
		}
		when ( inteiro ( cc ) ) -> {
			case 13.0 -> {
				auxiliar = 1313.0;
			}
			case 7.0 -> {
				auxiliar = 7070.0;
			}others {
				if ( inteiro ( cc ) == 9.0 ) -> {
					auxiliar = 9090.0;
				}
				
			}
			
		}
		daz ( inteiro ( cc ) ) -> {
			extrem ( 0.0 , 5.0 ) -> {
				auxiliar = 55555.0;
			}
			
		}
		println ( "  - Numero : ", cc );
		println ( "  - Inteiro : ", inteiro ( cc ) );
		println ( "  - Decimal : ", decimal ( cc ) );
		println ( "  - Auxilar : ", auxiliar );
		a1 = somar ( a1 , 1.0 );
	}
	print_empty();

	invoke __COMPILER__ -> SHOW_GLOBAL ( ) :: ALL;
}

act operar ( geral : num ) {
	operando ( somar ( 3.0 , geral ) );
}
mockiz OPERANTE : num = 2.0;
define SGeral : num = somar ( 2.0 , 2.0 );
call iniciar -> operar ( OPERANTE );
