call iniciar -> operando ( );
act operando ( ) {
	moc PARAR : int = 10;
	moc PASSO : int = 1;
	moc MSG_PAR : string = " : PAR ";
	moc MSG_IMPAR : string = " : IMPAR ";
	step def numero : int :: ( 0 , PARAR , somar ( numero , PASSO ) ) -> {
		def resto : int = resto ( numero , 2 );
		if ( resto == 0 ) -> {
			println ( numero , MSG_PAR );
		}
		if ( resto == 1 ) -> {
			println ( numero , MSG_IMPAR );
		}
		
	}
	
}
func somar ( a : int , b : int ) : int {
	reg @ R5 -> a;
	reg @ R6 -> b;
	PROC -> {
		SET R7;
		MOV 0;
		OPE R5 ADD R6;
	}
	return reg @ R7;
}
func resto ( a : int , b : int ) : int {
	reg @ R5 -> a;
	reg @ R6 -> b;
	PROC -> {
		SET R7;
		MOV 0;
		OPE R5 MOD R6;
	}
	return reg @ R7;
}

act println ( a : int , b : string ) {
	reg @ R5 -> a;
	reg @ R13 -> b;
	PROC -> {
		PROC CHANGE_LINE;
		SET R14;
		MOV "";
		INT_STRING R5;
		PRINT R14;
		PRINT R13;
	}
	
}

act println ( a : string , b : int ) {
	reg @ R13 -> a;
	reg @ R5 -> b;
	PROC -> {
		PROC CHANGE_LINE;
		PRINT R13;
		SET R13;
		MOV "";
		INT_STRING R5;
		PRINT R13;
	}
	
}
func menor ( a : int , b : int ) : bool {
	reg @ R5 -> a;
	reg @ R6 -> b;
	PROC -> {
		SET R1;
		MOV FALSE;
		OPE R5 LESS R6;
	}
	return reg @ R1;
}
operator == ( a : int , b : int ) : bool {
	reg @ R5 -> a;
	reg @ R6 -> b;
	PROC -> {
		SET R1;
		MOV FALSE;
		OPE R5 EQUAL R6;
	}
	return reg @ R1;
}
