call iniciar -> inicio ( );
act println ( a : string , b : int ) {
	def c : int;
	invoke terminal -> change ( ) :: c;
	invoke terminal -> print ( a ) :: c;
	invoke terminal -> print ( b ) :: c;
}

act println ( a : string , b : bool ) {
	def c : int;
	invoke terminal -> change ( ) :: c;
	invoke terminal -> print ( a ) :: c;
	invoke terminal -> print ( b ) :: c;
}
func isNull ( ObjetoNulo : any ) : bool {
	def c : bool;
	invoke casting -> cast_isnull ( ObjetoNulo ) :: c;
	return c;
}
func int ( a : int ) : int {
	return a;
}
operator ++ ( a : int , b : int ) : int {
	def c : int;
	invoke math -> operator_sum_int ( a , b ) :: c;
	return c;
}
operator -- ( a : int , b : int ) : int {
	def c : int;
	invoke math -> operator_sub_int ( a , b ) :: c;
	return c;
}
operator ** ( a : int , b : int ) : int {
	def c : int;
	invoke math -> operator_mux_int ( a , b ) :: c;
	return c;
}
operator // ( a : int , b : int ) : int {
	def c : int;
	invoke math -> operator_div_int ( a , b ) :: c;
	return c;
}
operator == ( a : int , b : int ) : bool {
	def c : bool;
	def c1 : int = a;
	def c2 : int = b;
	invoke math -> operator_equal_int ( c1 , c2 ) :: c;
	return c;
}
operator !! ( a : int , b : int ) : bool {
	def c : bool;
	def c1 : int = a;
	def c2 : int = b;
	invoke math -> operator_not_int ( c1 , c2 ) :: c;
	return c;
}
director ! ( a : int ) : int {
	def b : int = a ++ int ( ( -1 ) );
	return b;
}
func somar ( a : int , b : int ) : int {
	def c1 : int = null;
	def a1 : int = a;
	def b1 : int = b;
	invoke math -> operator_sum_int ( a1 , b1 ) :: c1;
	def c : int = c1;
	return c;
}
func subtrair ( a : int , b : int ) : int {
	def c1 : int = null;
	def a1 : int = a;
	def b1 : int = b;
	invoke math -> operator_sub_int ( a1 , b1 ) :: c1;
	def c : int = c1;
	return c;
}
func multiplicar ( a : int , b : int ) : int {
	def c1 : int = null;
	def a1 : int = a;
	def b1 : int = b;
	invoke math -> operator_mux_int ( a1 , b1 ) :: c1;
	def c : int = c1;
	return c;
}
func dividir ( a : int , b : int ) : int {
	def c1 : int = null;
	def a1 : int = a;
	def b1 : int = b;
	invoke math -> operator_div_int ( a1 , b1 ) :: c1;
	def c : int = c1;
	return c;
}
func resto ( a : int , b : int ) : int {
	def c : int;
	invoke math -> operator_mod_int ( a , b ) :: c;
	return c;
}
func menor ( a : int , b : int ) : bool {
	def c : bool;
	invoke math -> operator_less_int ( a , b ) :: c;
	return c;
}
func maior ( a : int , b : int ) : bool {
	def c : bool;
	invoke math -> operator_great_int ( a , b ) :: c;
	return c;
}
func menor_igual ( a : int , b : int ) : bool {
	def c1 : bool = false;
	def c2 : bool = false;
	invoke math -> operator_less_int ( a , b ) :: c1;
	invoke math -> operator_equal_int ( a , b ) :: c2;
	return operador_ou ( c1 , c2 );
}
func igual ( a : int , b : int ) : bool {
	def c : bool;
	invoke math -> operator_equal_int ( a , b ) :: c;
	return c;
}
func diferente ( a : int , b : int ) : bool {
	def a1 : int = a;
	def b1 : int = b;
	def c : bool;
	invoke math -> operator_not_int ( a1 , b1 ) :: c;
	return c;
}
operator !! ( a : bool , b : bool ) : bool {
	def c : bool;
	invoke math -> operator_unmatch ( a , b ) :: c;
	return c;
}

act trash ( a : any ) {
	def existe : bool = false;
	invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;
	invoke __COMPILER__ -> EXISTS ( a ) :: existe;
	invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;
	if ( existe ) -> {
		invoke __COMPILER__ -> OBJECT ( a ) :: REMOVE;
	}
	
}

struct Lista in ( T ) {
	restrict : 
	define mPrimeiro : Item >> ( T ) = null;
	define mUltimo : Item >> ( T ) = null;
	define mQuantidade : int = 0;
	all : 
	func getQuantidade ( ) : int {
		return mQuantidade;
	}

	act adicionar ( novo : T ) {
		
		#println ( "Adicionando : ", novo );
		if ( isNull ( mPrimeiro ) ) -> {
			
			#println ( "Adicionando EM NULO : ", novo );
			mPrimeiro = init Item ( ) >> ( T );
			mPrimeiro.setValor ( novo );
			mUltimo = mPrimeiro;
			mQuantidade = 1;
			
			#println ( "Adicionado EM NULO : ", novo );
			
		}others {
			
			#println ( "Adicionando NAO NULO : ", novo );
			def mCorrente : Item >> ( T ) = init Item ( ) >> ( T );
			mCorrente.setValor ( novo );
			mUltimo.setProximo ( mCorrente );
			mUltimo = mCorrente;
			mQuantidade = somar ( mQuantidade , 1 );
			
			#println ( "Adicionado NAO NULO : ", novo );
			
		}
		
		#println ( "Adicionado : ", novo );
		
	}

	act remover ( a : T ) {
		
		#println ( "Removendo : ", a );
		if ( isNull ( mPrimeiro ) ) -> {
			
		}others {
			def mAnterior : Item >> ( T ) = null;
			def mCorrente : Item >> ( T ) = mPrimeiro;
			def mIndice : int = 0;
			def mUltimoIndice : int = somar ( mQuantidade , 1 );
			while ( isNull ( mCorrente ) == false ) -> {
				if ( mCorrente.getValor ( ) == a ) -> {
					println ( "Removendo : ", a );
					if ( mIndice == 0 ) -> {
						if ( mQuantidade == 1 ) -> {
							mPrimeiro = null;
							mUltimo = null;
						}others {
							mPrimeiro = mPrimeiro.getProximo ( );
						}
						
					}other ( mIndice == mUltimoIndice ) -> {
						mAnterior.setProximo ( null );
						mUltimo = mAnterior;
					}others {
						mAnterior.setProximo ( mCorrente.getProximo ( ) );
					}
					mQuantidade = subtrair ( mQuantidade , 1 );
					trash ( mCorrente );
					cancel;
				}
				
				#println("Passando Por : ",mCorrente.getValor());
				mAnterior = mCorrente;
				mCorrente = mCorrente.getProximo ( );
				mIndice = somar ( mIndice , 1 );
			}
			
		}
		
	}

	act listar ( ) {
		if ( isNull ( mPrimeiro ) == false ) -> {
			def mCorrente : Item >> ( T ) = mPrimeiro;
			while ( isNull ( mCorrente ) == false ) -> {
				println ( " - Valor : ", mCorrente.getValor ( ) );
				mCorrente = mCorrente.getProximo ( );
			}
			
		}
		
	}

	act limpar ( ) {
		if ( isNull ( mPrimeiro ) == false ) -> {
			def mCorrente : Item >> ( T ) = mPrimeiro;
			def mAnterior : Item >> ( T ) = mPrimeiro;
			while ( isNull ( mCorrente ) == false ) -> {
				mAnterior = mCorrente;
				mCorrente = mCorrente.getProximo ( );
				trash ( mAnterior );
			}
			trash ( mAnterior );
		}
		mPrimeiro = null;
		mUltimo = null;
	}
	func getValor ( indice : int ) : T {
		def ret : int = null;
		if ( maior_igual ( indice , 0 ) ) -> {
			def contando : int = 0;
			def enc : bool = false;
			if ( isNull ( mPrimeiro ) == false ) -> {
				def mCorrente : Item >> ( T ) = mPrimeiro;
				while ( isNull ( mCorrente ) == false ) -> {
					if ( contando == indice ) -> {
						ret = mCorrente.getValor ( );
						enc = true;
					}
					contando = somar ( contando , 1 );
					mCorrente = mCorrente.getProximo ( );
				}
				
			}
			if ( enc == false ) -> {
				exception "Indice invalido !";
			}
			
		}others {
			exception "Indice invalido !";
		}
		return ret;
	}
	
}

struct Item in ( T ) {
	restrict : 
	define mValor : T = null;
	define mProximo : Item >> ( T ) = null;
	all : 
	func getValor ( ) : T {
		return mValor;
	}

	act setValor ( eValor : T ) {
		mValor = eValor;
	}
	func getProximo ( ) : Item >> ( T ) {
		def tmp : Item >> ( T ) = mProximo;
		return tmp;
	}

	act setProximo ( eProximo : Item >> ( T ) ) {
		mProximo = eProximo;
	}
	func getProximo ( ) : Item >> ( T ) {
		return mProximo;
	}
	
}

struct Iterador in ( T ) {
	init Iterador ( eLista : T ) {
		mLista = eLista;
		mIndex = 0;
		mTamanho = 0;
		mIniciado = false;
		mTerminou = false;
	}
	restrict : 
	define mLista : T = null;
	define mIndex : int = 0;
	define mTamanho : int = 0;
	define mIniciado : bool = false;
	define mTerminou : bool = false;
	all : 
	act iniciar ( ) {
		mIndex = 0;
		mTamanho = mLista.getQuantidade ( );
		mIniciado = true;
		mTerminou = false;
	}

	act proximo ( ) {
		if ( mIniciado ) -> {
			if ( mTerminou == false ) -> {
				if ( menor ( mIndex , mTamanho ) ) -> {
					def um : int = 1;
					mIndex = somar ( mIndex , um );
				}others {
					mTerminou = true;
				}
				
			}
			
		}
		
	}
	func continuar ( ) : bool {
		def ret : bool = false;
		if ( mIniciado ) -> {
			if ( maior_igual ( mIndex , mTamanho ) ) -> {
				mTerminou = true;
			}others {
				ret = true;
			}
			
		}others {
			ret = false;
		}
		return ret;
	}
	func getIndex ( ) : int {
		if ( mIniciado ) -> {
			
		}others {
			exception "O iterador nao foi iniciado !";
		}
		return mIndex;
	}
	func getValor ( ) : T {
		def ii : int = getIndex ( );
		return mLista.getValor ( ii );
	}
	
}
refer Delicia;
act inicio ( ) {
	def ls : Lista >> ( string ) = init Lista ( ) >> ( string );
	def lsi : Iterador >> ( Lista >> ( string ) ) = init Iterador ( ls ) >> ( Lista >> ( string ) );
	def ig : Lista >> ( int ) = init Lista ( ) >> ( int );
	ig.adicionar ( 10 );
	ig.adicionar ( 20 );
	def a : int = ig.getQuantidade ( );
	ig.adicionar ( 30 );
	ig.adicionar ( 40 );
	ig.adicionar ( 50 );
	ig.adicionar ( 60 );
	def b : int = ig.getQuantidade ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	
	#ig.listar ( );
	println ( " DEBUG  ", 0 );
	def iterando : Iterador >> ( Lista >> ( int ) ) = init Iterador ( ig ) >> ( Lista >> ( int ) );
	iterando.iniciar ( );
	println ( " DEBUG  ", 1 );
	while ( iterando.continuar ( ) ) -> {
		println ( "-> ", iterando.getValor ( ) );
		iterando.proximo ( );
	}
	println ( " DEBUG  ", 2 );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.remover ( 10 );
	ig.listar ( );
	println ( "Quantidade  : ", ig.getQuantidade ( ) );
	ig.remover ( 40 );
	ig.listar ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.remover ( 60 );
	ig.listar ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.remover ( 15 );
	ig.listar ( );
	println ( "Quantidade # : ", ig.getQuantidade ( ) );
	ig.adicionar ( 70 );
	
	#ig.listar ( );
	iterando.iniciar ( );
	while ( iterando.continuar ( ) ) -> {
		println ( "-> ", iterando.getValor ( ) );
		iterando.proximo ( );
	}
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.remover ( 50 );
	ig.remover ( 20 );
	ig.adicionar ( 15 );
	ig.remover ( 70 );
	ig.remover ( 15 );
	ig.remover ( 30 );
	ig.remover ( 15 );
	ig.listar ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.adicionar ( 5 );
	ig.adicionar ( 2 );
	ig.adicionar ( 3 );
	ig.listar ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.limpar ( );
	ig.listar ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.adicionar ( 1000 );
	ig.listar ( );
	println ( "Quantidade : ", ig.getQuantidade ( ) );
	ig.adicionar ( 40 );
	ig.adicionar ( 12 );
	ig.adicionar ( 60 );
	ig.adicionar ( 87 );
	ig.adicionar ( 90 );
	def iterar : Iterador >> ( Lista >> ( int ) ) = init Iterador ( ig ) >> ( Lista >> ( int ) );
	iterar.iniciar ( );
	while ( iterar.continuar ( ) ) -> {
		println ( "-> ", iterar.getValor ( ) );
		iterar.proximo ( );
	}
	def Frutas : Lista >> ( Fruta ) = init Lista ( ) >> ( Fruta );
	invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;
	Frutas.adicionar ( init Fruta ( ) );
	
	#invoke __COMPILER__ -> SHOW_GLOBAL ( ) :: STACK;
	
	#invoke __COMPILER__ -> HEAP ( ) :: ALL;
	
}
package Delicia {
	struct Fruta {
		
	}
	
}
func operador_e ( a : bool , b : bool ) : bool {
	def c : bool = false;
	if ( a == true ) -> {
		if ( b == true ) -> {
			c = true;
		}
		
	}
	return c;
}
func operador_ou ( a : bool , b : bool ) : bool {
	def c : bool = false;
	if ( a == true ) -> {
		c = true;
	}
	if ( b == true ) -> {
		c = true;
	}
	return c;
}
operator == ( a : bool , b : bool ) : bool {
	def c : bool;
	invoke math -> operator_match ( a , b ) :: c;
	return c;
}
func maior_igual ( a : int , b : int ) : bool {
	def c1 : bool = false;
	def c2 : bool = false;
	invoke math -> operator_great_int ( a , b ) :: c1;
	invoke math -> operator_equal_int ( a , b ) :: c2;
	def c3 : bool = operador_ou ( c1 , c2 );
	return c3;
}
