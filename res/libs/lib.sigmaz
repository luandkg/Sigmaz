mockiz SIGMAZ : string = "SIGMAZ 1.0";
mockiz VERSAO : num = 1.0;
import "constant.sigmaz";
import "operators.sigmaz";
import "functions.sigmaz";
import "comparators.sigmaz";
import "terminal.sigmaz";
import "cast.sigmaz";
import "strings.sigmaz";
import "pos.sigmaz";
import "neg.sigmaz";
import "int.sigmaz";
import "lista/lista.sigmaz";
import "lista/iterador.sigmaz";
import "pacote_tempo.sigmaz";
import "ecossistema.sigmaz";
stages Numeros -> {
	POSITIVO , NEGATIVO , ZERO 
}
stages Comparacao -> {
	MAIOR , MENOR , IGUAL 
}
stages Logico -> {
	TRUE , FALSE 
}
type Par in ( T1 , T2 ) {
	define chave : T1 = null;
	define valor : T2 = null;
}

act trash ( a : any ) {
	invoke __COMPILER__ -> OBJECT ( a ) :: REMOVE;
}
director ! ( a : bool ) : bool {
	invoke casting -> inverse ( a ) :: a;
	return a;
}
func typeof ( a : any ) : string {
	def ret : string = "";
	invoke casting -> typeof ( a ) :: ret;
	return ret;
}
type Tipado {
	define A : num = 0;
	define B : num = 0;
}
operator ++ ( a : Tipado , b : Tipado ) : Tipado {
	return start Tipado {
		A = somar_inteiro ( a.A , b.A );
		B = somar_inteiro ( a.B , b.B );
	};
	
}

struct TesteGeral {
	all : 
	define A : string = "";
	
	#operator ++ (a:Tipado,b:Tipado) : Tipado { return start Tipado {A=somar_inteiro(a.A,b.A); B = somar_inteiro(a.B,b.B);}; }
	restrict : 
	define B : string = "";
	
	#implicit:
	
	#   define C : num = 0;
	extern : 
	define C : num = 0;
	act AumentarC ( ) {
		TesteGeral -> C = somar_inteiro ( TesteGeral -> C , 1 );
	}
	func ObterC ( ) : num {
		return TesteGeral -> C;
	}
	
}
