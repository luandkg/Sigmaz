mockiz SIGMAZ : string = "SIGMAZ 1.0";
mockiz VERSAO : num = 1.0;
define ALTERAVAL : int = 0;
import "constant.sigmaz";
import "functions.sigmaz";
import "comparators.sigmaz";
import "terminal.sigmaz";
import "cast.sigmaz";
import "strings.sigmaz";
import "bool.sigmaz";
import "int.sigmaz";
import "num.sigmaz";
import "int_num.sigmaz";
import "pos.sigmaz";
import "neg.sigmaz";
import "container/lista.sigmaz";
import "container/vetor.sigmaz";
import "container/iterador.sigmaz";
import "pacote_tempo.sigmaz";

import "ecossistema.sigmaz";
import "cores.sigmaz";
import "unit.sigmaz";
import "marcadores.sigmaz";
import "idealismo.sigmaz";
stages Numeros -> {
	POSITIVO , NEGATIVO , ZERO 
}
stages Comparacao -> {
	MAIOR , MENOR , IGUAL 
}
stages Logico -> {
	TRUE , FALSE 
}
type Par in ( T1 , T2 ) {
	define chave : T1 = null;
	define valor : T2 = null;
}

act trash ( a : any ) {
	invoke __COMPILER__ -> OBJECT ( a ) :: REMOVE;
}
func isNull ( ObjetoNulo : any ) : bool {
	def c : bool;
	invoke casting -> cast_isnull ( ObjetoNulo ) :: c;
	return c;
}
director ! ( a : bool ) : bool {
	invoke casting -> inverse ( a ) :: a;
	return a;
}
func typeof ( a : any ) : string {
	def ret : string = "";
	invoke casting -> typeof ( a ) :: ret;
	return ret;
}
type Tipado {
	define A : int = 0;
	define B : int = 0;
}
operator ++ ( a : Tipado , b : Tipado ) : Tipado {
	return start Tipado {
		A = somar ( a.A , b.A );
		B = somar ( a.B , b.B );
	};
	
}

struct TesteGeral {
	all : 
	define A : string = "";
	
	#operator ++ (a:Tipado,b:Tipado) : Tipado { return start Tipado {A=somar_inteiro(a.A,b.A); B = somar_inteiro(a.B,b.B);}; }
	restrict : 
	define B : string = "";
	
	#implicit:
	
	#   define C : num = 0;
	explicit : define C : int = 0;
	act AumentarC ( ) {
		TesteGeral -> C = somar ( TesteGeral -> C , 1 );
	}
	func ObterC ( ) : int {
		return TesteGeral -> C;
	}
	
}

struct Objeto {
	all : 
	act trash ( ) {
		invoke __COMPILER__ -> OBJECT ( this ) :: REMOVE;
	}
	func equal ( ObjetoCorrente : Objeto ) : bool {
		return false;
	}
	func hash ( ) : string {
		return "";
	}
	
}

struct O1 with Objeto {
	init O1 ( ) -> Objeto ( ) {
		
	}
	
}

struct O2 with Objeto {
	init O2 ( ) -> Objeto ( ) {
		
	}
	
}

struct O3 with Objeto {
	restrict : 
	define mValor : int = 0;
	all : 
	init O3 ( eValor : int ) -> Objeto ( ) {
		mValor = eValor;
	}
	func equal ( ObjetoCorrente : O3 ) : bool {
		return this.mValor == ObjetoCorrente.getValor ( );
	}
	func getValor ( ) : int {
		return mValor;
	}
	allow : func hash ( ) : string {
		return "@OBJETO::O3";
	}
	
}
functor < T1 , T2 , T3 > somatorio ( a1 : T1 , a2 : T2 ) : T3 {
	def retorno : T3 = a1 ++ a2;
	return retorno;
}
auto < T1 , T2 , T3 > autosoma ( a1 : T1 , a2 : T2 ) {
	def somando : T3 = a1 ++ a2;
}
