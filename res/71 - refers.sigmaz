
package Blocos {

    struct CX in (T) {

    restrict:
          define mValor : T = null;

    }

    struct CXA in (T) with CX  {

        init CXA( eValor : T ) -> CX () {
            this.mValor = eValor;
        }



        all:

            func getValor() :  T {return this.mValor;}

            act aumentar(eValor: T) {
                this.mValor = mValor ++ eValor;
            }

            act diminuir(eValor: T) {
                this.mValor = mValor -- eValor;
            }

            operator ++(a:CXA >> (T),b:CXA >> (T)) : CXA >> (T){



                def tt : T = a.getValor() ++ b.getValor();
 invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;

                return init CXA(tt) >> (T);
            }
            director !(a:CXA >> (T)) : CXA {
                return init CXA(a.getValor() ** (-1)) >> (T);
            }
    }

}

refer Blocos;

call iniciar -> {

    def a1 : CXA >> (num) = init CXA(12) >> (num);
    def a2 : CXA >> (num)  = init CXA(18) >> (num);

    def a1_valor : num = a1.getValor();
    def a2_valor : num = a2.getValor();

    def tt : bool =true;

   # invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;

    def a3 : CXA >> (num) = a1 ++ a2;

    invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;

    def a3_valor : num = a3.getValor();

    def a4 : CXA >> (num) = !a3;
    def a4_valor : num = a4.getValor();

    a4.aumentar(10);

    def a4_valor2 : num = a4.getValor();

  #  def a : string = a4;

    def r : num = azucrinar(1,2);



    invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;

}

func azucrinar(a:bool) : num {

return -1;

}

func azucrinar(a:num,b:num) : num {

return -1;

}


operator ++ ( a : num , b : num ) : num {
	def c : num;
	invoke math -> operator_sum ( a , b ) :: c;
	return c;
}

operator -- ( a : num , b : num ) : num {
	def c : num;
	invoke math -> operator_sub ( a , b ) :: c;
	return c;
}

operator ** ( a : num , b : num ) : num {
	def c : num;
	invoke math -> operator_mux ( a , b ) :: c;
	return c;
}