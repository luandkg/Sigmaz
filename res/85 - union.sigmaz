
type Quad {

    define a : int = 0;
    define b : int = 0;

}

type Mesh {

    define c : int = 0;
    define d : int = 0;

}


type Cot {

}

type Quadrante in (T) {

    define a : T = null;
    define b : T = null;

}

type Meshante in (T) {

    define c : T = null;
    define d : T = null;

}

type QuadMesh union Quad :: Mesh;

type QuadranteMesh union Quadrante >> (int) :: Mesh;

type QuadranteMesh_GS in (A) union Quadrante >> (A) :: Mesh;

type QuaMeshante_GS in (A) union Quad  :: Meshante >> (A) ;

type QuadranteMeshante in (T,S) union Quadrante >> (T) :: Meshante >> (S);

call iniciar ->  {

    def QuadMesh_1 : QuadMesh = start QuadMesh { a = 1; b=2; c=3; d=4; };

    def QuadMesh_1_a : int = QuadMesh_1.a;
    def QuadMesh_1_b : int = QuadMesh_1.b;
    def QuadMesh_1_c : int = QuadMesh_1.c;
    def QuadMesh_1_d : int = QuadMesh_1.d;


    def Mesh_1 : Mesh = QuadMesh_1;
    def Mesh_1_C : int = Mesh_1.c;

    def QuadranteMeshante_1 : QuadranteMeshante >> (int,num) = start QuadranteMeshante >> (int,num) { a = 1; b=2; c=3.0; d=4.0; };

    def Meshante_1  : Meshante = QuadranteMeshante_1;

    def Meshante_1_C : num = Meshante_1.c;

    dentro(30);

    def aa : int = somatorio(3,7);

    def bb : int = 10 ++ 12;
    def cc : int = !-5;

	invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;

}



act dentro(v : int){

	invoke __COMPILER__ -> SHOW_SCOPE ( ) :: STACK;

}

func somatorio(a:int,b:int) : int {

	reg @R5 -> a;
    reg @R6 -> b;

     PROC -> {

        SET R7;
            MOV 0;
            OPE R5 ADD R6;

     }

	return reg @R7;

}


operator ++(a:int,b:int) : int {

	reg @R5 -> a;
    reg @R6 -> b;

     PROC -> {

        SET R7;
            MOV 0;
            OPE R5 ADD R6;

     }

	return reg @R7;

}


director !(a:int) : int {

	reg @R5 -> a;

     PROC -> {

        SET R6;
            MOV 0;
            OPE R5 MUX -1;

     }

	return reg @R6;

}


